---
layout: photo
title: 测试-python模块和包
tags:
  - null
date: 2022-03-07 14:59:59
categories:
photos:
---
学习python中模块和包的概念
<!--more-->
### Python常用的标准库
os 操作系统，time 时间，random 随机，pymysql 连接数据库，threading 线程，multiprocessing 进程，queue 队列。
第三方库:django 和 flask 也是第三方库，requests，virtualenv，selenium，scrapy，xadmin，celery， re，hashlib，md5。
常用的科学计算库(如 Numpy，Scipy，Pandas)。

### 赋值、浅拷贝和深拷贝
一、 赋值在Python中，对象的赋值就是简单的对象引用，这点和 C++不同，如下所示: 
a = [1,2,"hello",['python', 'C++']]
b= a
在上述情况下，a和b是一样的，他们指向同一片内存，b不过是a的别名，是引用。
我们可以使用 b is a 去判断，返回 True，表明他们地址相同，内容相同，也可以使用id()函数来查看两个列 表的地址是否相同。
赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间，它只是复制了对象的引用。也就是 说除了b这个名字之外，没有其他的内存开销。修改了a，也就影响了b，同理，修改了b，也就影响了a。
二、 浅拷贝(shallow copy)
浅拷贝会创建新对象，其内容非原对象本身的引用，而是原对象内第一层对象的引用。
浅拷贝有三种形式:切片操作、工厂函数、copy模块中的copy函数。
比如上述的列表a;
切片操作:b = a[:] 或者 b = [x for x in a];
工厂函数:b = list(a);
copy 函数:b = copy.copy(a);
浅拷贝产生的列表b不再是列表a了，使用is判断可以发现他们不是同一个对象，使用id查看，他们也不指向同一片内存空间。但是当我们使用 id(x) for x in a 和 id(x) for x in b 来查看a和b中元素的地址时，可以看到二者包含的元素的地址是相同的。
在这种情况下，列表a和b是不同的对象，修改列表b理论上不会影响到列表a。 但是要注意的是，浅拷贝之所以称之为浅拷贝，是它仅仅只拷贝了一层，在列表a中有一个嵌套的list，如果我们修改了它，情况就不一样了。
比如:a[3].append('java')。查看列表b，会发现列表b也发生了变化，这是因为，我们修改了嵌套的list，修改外层元素，会修改它的引用，让它们指向别的位置，修改嵌套列表中的元素，列表的地址并未发生变化，指向的都是用一个位置。
三、深拷贝(deep copy)
深拷贝只有一种形式，copy模块中的deepcopy()函数。 深拷贝和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。因此，它的时间和空间开销要高。
同样的对列表a，如果使用b = copy.deepcopy(a)，再修改列表b将不会影响到列表a，即使嵌套的列表具有更深的层次，也不会产生任何影响，因为深拷贝拷贝出来的对象根本就是一个全新的对象，不再与原来的对象有任何的关联。 
四、拷贝的注意点
对于非容器类型，如数字、字符，以及其他的“原子”类型，没有拷贝一说，产生的都是原对象的引用。 如果元组变量值包含原子类型对象，即使采用了深拷贝，也只能得到浅拷贝。

### __init__ 和__new__区别
init 在对象创建后，对对象进行初始化。
new 是在对象创建之前创建一个对象，并将该对象返回给 init。 

### Python 生成随机数
在 Python 中用于生成随机数的模块是 random，在使用前需要 import.
如下例子可以酌情列举:
random.random(): 生成一个 0-1 之间的随机浮点数; 
random.uniform(a, b): 生成[a,b]之间的浮点数; 
random.randint(a, b): 生成[a,b]之间的整数;
random.randrange(a, b, step): 在指定的集合[a,b)中，以 step 为基数随机取一个数; 
random.choice(sequence): 从特定序列中随机取一个元素，这里的序列可以是字符串，列表，元组等。

### 输入某年某月某日，判断这一天是这一年的第几天
```python
import datetime

def dayofyear():
	year = input("请输入年份:")
	month = input("请输入月份:")
	day = input("请输入天:")
	date1 = datetime.date(year=int(year),	month=int(month)，day=int(day)) 
	date2 = datetime.date(year=int(year)，month=1，day=1)
	return (date1 - date2 + 1).days
```

### 打乱一个排好序的 list 对象 alist? 
```python
import random
random.shuffle(alist)
```

### os.path 和 sys.path
os.path 主要是用于对系统路径文件的操作。 
sys.path 主要是对 Python 解释器的系统环境参数的操作
(动态的改变 Python 解释器搜索路径)。 

### Python 中的 os 模块常见方法
os.remove()删除文件
os.rename()重命名文件
os.walk()生成目录树下的所有文件名
os.chdir()改变目录
os.mkdir/makedirs 创建目录/多层目录
os.rmdir/removedirs 删除目录/多层目录
os.listdir()列出指定目录的文件
os.getcwd()取得当前工作目录
os.chmod()改变目录权限
os.path.basename()去掉目录路径，返回文件名
os.path.dirname()去掉文件名，返回目录路径
os.path.join()将分离的各部分组合成一个路径名
os.path.split()返回(dirname(),basename())元组
os.path.splitext()(返回 filename,extension)元组
os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间  os.path.getsize()返回文件大小     os.path.exists()是否存在
os.path.isabs()是否为绝对路径
os.path.isdir()是否为目录
os.path.isfile()是否为文件

### Python 的 sys 模块常用方法
sys.argv 命令行参数 List，第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback 当前处理的异常详细信息
sys.exit(n) 退出程序，正常退出时 exit(0)
sys.hexversion 获取 Python 解释程序的版本值，16进制格式如:0x020403F0
sys.version 获取 Python 解释程序的版本信息
sys.maxint 最大的 Int 值
sys.maxunicode 最大的 Unicode 值
sys.modules 返回系统导入的模块字段，key 是模块名，value 是模块
sys.path 返回模块的搜索路径，初始化时使用 PYTHONPATH 环境变量的值
sys.platform 返回操作系统平台名称
sys.stdout 标准输出
sys.stdin 标准输入
sys.stderr 错误输出
sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix 返回平台独立的 python 文件安装的位置
sys.byteorder 本地字节规则的指示器，big-endian 平台的值是'big',little-endian 平台的值是 'little'
sys.copyright 记录 python 版权相关的东西
sys.api_version 解释器的 C 的 API 版本
sys.version_info 元组则提供一个更简单的方法来使你的程序具备 Python 版本要求功能

### 模块和包
在 Python 中，模块是搭建程序的一种方式。
每一个 Python 代码文件都是一个模块，并可以引用其他的模块，比如对象和属性。
一个包含许多 Python 代码的文件夹是一个包。
一个包可以包含模块和子文件夹。