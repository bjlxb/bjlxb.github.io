---
layout: photo
title: 测试-Jmeter压测
tags:
  - 测试
date: 2022-03-15 21:03:34
categories: 测试
photos:
---
学习Jmeter压测相关内容。
<!--more-->
### Jmeter的七大原件
Test Plan（测试计划）：用于描述包含与此性能测试相关的所有功能的性能测试。换句话说，性能测试的所有内容都是基于一个计划。

Threads(Users) ：这个就是我们通常添加运行的线程。通俗的讲一个线程组,，可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户。线程组中包含的线程数量在测试执行过程中是不会发生改变的。

取样器(Sampler) ：取样器(Sample)是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元，JMeter 原生支持多种不同的sampler ，如 HTTP Request Sampler 、 FTP Request Sample 、TCP Request Sample 、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求

逻辑控制器(Logic Controller) ：逻辑控制器，包括两类无件，一类是用于控制test plan 中 sampler 节点发送请求的逻辑顺序的控制器，常用的有 如果(If)控制器 、switch Controller 、Runtime Controller、循环控制器等。另一类是用来组织可控制 sampler 来节点的，如 事务控制器、吞吐量控制器。

配置元件(Config Element) ：配置元件(config element)用于提供对静态数据配置的支持。CSV Data Set config 可以将本地数据文件形成数据池(Data Pool)，而对应于HTTP Request Sampler和 TCP Request Sampler等类型的配制无件则可以修改Sampler的默认数据。(例如，HTTP Cookie Manager 可以用于对 HTTP Request Sampler 的cookie 进行管理)

定时器(Timer) ：定时器(Timer)用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手端。类似于LoadRunner里面的“思考时间”。JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。

前置处理器(Per Processors) ：用于在实际的请求发出之前对即将发出的请求进行特殊处理。例如，HTTP URL重写修复符则可以实现URL重写，当RUL中有sessionID 一类的session信息时，可以通过该处理器填充发出请求的实际的sessionID 。

后置处理器(Post Processors) ：用于对Sampler 发出请求后得到的服务器响应进行处理。一般用来提取响应中的特定数据(类似LoadRunner测试工具中的关联概念)。例如，XPath Extractor 则可以用于提取响应数据中通过给定XPath 值获得的数据。

断言(Assertions) ：断言用于检查测试中得到的相应数据等是否符合预期，断言一般用来设置检查点，用以保证性能测试过程中的数据交互是否与预期一致。

监听器(Listener) ：这个监听器可不是用来监听系统资源的元件。它是用来对测试结果数据进行处理和可视化展示的一系列元件。 图行结果、查看结果树、聚合报告。都是我们经常用到的元件。

### 聚合报告每个字段意思
Label：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值。

#Samples：表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100。

Average：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间。

Median：中位数，也就是 50％ 用户的响应时间。

90%95%99% Line： 90％ 95％ 99％ 用户的响应时间。

Min：最小响应时间。

Max：最大响应时间。

Error%：本次测试中出现错误的请求的数量/请求的总数。

Throughput：吞吐量——默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数。

Received KB/Sec：每秒从服务器端接收到的数据量。

### 一台客户端有500个客户与500个客户端有300个用户对服务器施压的区别
500个用户在一个客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。
500个用户在一个客户端上，需要更大的带宽。
IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。
所有用户在一个客户端上，不必考虑分布式管理的问题；而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。

### Jmeter参数化
jdbc参数化，csv参数化，函数参数化，计数器参数化，mock参数化

### jmeter常用函数
random ：随机数
\_\_setProperty:设置全局变量
\_\_P:获取全局变量
\_\_count计数器：TRUE:用户单独技术  FALSE:不单独计数
\_\_CSVRead函数：循环读取由线程组控制
time函数：默认13位时间戳
beanshell
vars：put,get方法
// put获取已定义的变量给外部使用 
// get获取外部变量
vars.put("name1",name);  　　
vars.get("src_${num}")
log：日志  log.info()
prev：获取响应数据
ctx：获取请求/响应数据
props：获取jmeter变量--Debug Sampler

### jmeter断言
1、断言响应持续时间    
2、断言正则，json，xpath变量   
3、beanshell断言   
4、jmeter响应断言变量不需要$ ，断言文本，响应代码和响应信息，断言请求头和响应头，断言数据大小

### beanshell常用变量
```
vars：put,get方法  
//put获取已定义的变量给外部使用 get获取外部变量
vars.put("name1",name);  　　
vars.get("src_${num}")
```
log：日志  log.info()
prev：获取响应数据
ctx：获取请求/响应数据
props：获取jmeter变量--Debug Sampler

### 关联
Add -> Post Processors -> Regular Expresstion Extractor
正则，json,xpath 

