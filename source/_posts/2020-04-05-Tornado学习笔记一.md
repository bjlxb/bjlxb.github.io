---
layout: photo
title: Tornado学习笔记一
tags:
  - Python
date: 2020-04-05 23:07:25
categories: Python
photos:
---
记录一下Tornado框架的学习过程！
<!--more-->
#### 一、 Tornado介绍
Tornado是使用Python编写的一个强大的、可扩展的Web服务器。
Tornado就是我们在 FriendFeed 的 Web 服务器及其常用工具的开源版本 。Tornado 和主流 Web 服务器框架（包括大多数 Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对epoll的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。（关于如何扩容 服务器，以处理数以千计的客户端的连接的问题，请参阅The C10K problem）

#### 二、Tornado环境部署
首先需要安装python相关环境，然后从PyPI获取（使用easy_install或pip安装），或者从Github上下载源码编译安装。
```python
# 使用pip进行安装
pip install tornado
# 下载源码进行安装
# 1.解压缩源码
# 2.进入解压后的页面
python setup.py build
sudo python setup.py install
```
#### 三、Tornado简单例子

```python
# hello.py
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```
启动程序命令：
```python
python hello.py --port=8000
```
浏览器直接访问或使用curl进行访问：
```shell
$ curl http://localhost:8000/
# 响应
Hello, friendly user!
$ curl http://localhost:8000/?greeting=Salutations
# 响应
Salutations, friendly user!
```
##### 例子解析：
```python
from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)
```
1. tornado.options模块从命令行中读取设置，使用这个模块指定我们的应用监听HTTP请求的端口。
2. 如果一个与define语句中同名的设置在命令行中被给出，那么它将成为全局options的一个属性。
3. 用户如果运行程序时使用了--help选项，程序将打印出所有你定义的选项以及你在define函数的help参数中指定的文本。如果用户没有为这个选项指定值，则使用default的值进行代替。
4. define函数使用type参数进行基本的参数类型验证，当不合适的类型被给出时抛出一个异常。
5. 如例子所示，允许一个整数的port参数作为options.port来访问程序。如果用户没有指定值，则默认为8000。
```python
class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')
```
1. Tornado的请求处理函数类
2. Tornado将这个类实例化，并调用与HTTP请求方法所对应的方法。
3. 因为只定义了一个get方法，这个处理函数将对HTTP的GET请求作出响应。
```python
greeting = self.get_argument('greeting', 'Hello')
```
get_argument从一个请求字符串中取得参数greeting的值。
如果参数没有出现在请求中，Tornado将使用get_argument的第二个参数作为默认值。
```python
self.write(greeting + ', friendly user!')
```
write是一个字符串作为函数的参数，HTTP响应中返回该字符串。
```python
if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
```
1. 使用Tornado的options模块来解析命令行。
2. 创建一个Tornado的Application类的实例。
3. 传递给Application类__init__方法的最重要的参数是handlers。
4. handlers告诉Tornado应该用哪个类来响应请求。
```python
http_server = tornado.httpserver.HTTPServer(app)
http_server.listen(options.port)
tornado.ioloop.IOLoop.instance().start()
```
1. Application对象被创建后将其传递给Tornado的HTTPServer对象。
2. 使用命令行指定的端口进行监听（通过options对象取出）。
3. 程序接收HTTP请求后，创建一个Tornado的IOLoop的实例。 

###### handlers解析
```python
app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
```
1. handlers值得我们更加深入的研究。
2. 由元组组成的列表，每个元组的第一个元素是一个用于匹配的正则表达式，第二个元素是一个RequestHanlder的子类。
###### 正则表达式指定路径
1. Tornado在元组中使用正则表达式来匹配HTTP请求的路径。
2. 这个路径是URL中主机名后面的部分，不包括查询字符串和碎片。
3. Tornado把这些正则表达式看作已经包含了行开始和结束锚点，即字符串"/"被看作为"^/$"。
4. 一个正则表达式包含一个捕获分组（正则表达式中的部分被括号括起来），匹配的内容将作为相应HTTP请求的参数传到RequestHandler对象中。

#### 四、GET和POST带参请求例子
```python
# string_service.py
import textwrap

import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class ReverseHandler(tornado.web.RequestHandler):
    def get(self, input):
        self.write(input[::-1])

class WrapHandler(tornado.web.RequestHandler):
    def post(self):
        text = self.get_argument('text')
        width = self.get_argument('width', 40)
        self.write(textwrap.fill(text, int(width)))
        
if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(
        handlers=[
            (r"/reverse/(\w+)", ReverseHandler),
            (r"/wrap", WrapHandler)
        ]
    )
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```
命令行运行：
```shell
python string_service.py --port=8000
```
请求链接和返回值：
```shell
# GET请求
curl http://localhost:8000/reverse/stressed
# 响应
desserts
curl http://localhost:8000/reverse/slipup
# 响应
pupils
# POST请求
http://localhost:8000/wrap -d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.
# 响应
Lorem ipsum dolor sit amet, consectetuer
adipiscing elit.
```
###### 代码讲解
Application类在"handlers"参数中实例化了两个RequestHandler子类对象。
```python
app = tornado.web.Application(handlers=[
    (r"/reverse/(\w+)", ReverseHandler),
    (r"/wrap", WrapHandler)
])
```
1. 使用正则表达式匹配以字符串/reverse/开始并紧跟着一个或多个字母的路径。
2. Tornado保存匹配括号中表达式的字符串，将其作为参数传递给RequestHandler的子类中。
```python
class ReverseHandler(tornado.web.RequestHandler):
    def get(self, input):
        self.write(input[::-1])
```
1. 	get方法有一个额外的参数input，这个参数将包含正则表达式匹配的第一个括号里的字符串。
2. 	如果正则表达式中有一系列额外的括号，匹配的字符串将被按照在正则表达式中出现的顺序作为额外的参数传递进来。
```python
class WrapHandler(tornado.web.RequestHandler):
    def post(self):
        text = self.get_argument('text')
        width = self.get_argument('width', 40)
        self.write(textwrap.fill(text, int(width)))
```
1. WrapHandler类定义了一个post方法，该类可以接收HTTP的POST方法的请求。
2. 使用RequestHandler对象的get_argument方法来捕获POST请求传递的参数。（Tornado可以解析URLencoded和multipart结构的POST请求）。
3. 从POST中获得了文本和宽度的参数，可以使用Python内建的textwrap模块来指定宽度装饰文本，并将结果字符串写回到HTTP响应中。

#### 错误处理
使用RequestHandler类的set_status()方法显式地设置HTTP状态码。
Tornado会自动地设置HTTP状态码。下面是一个常用情况的纲要：

------

404 Not Found
Tornado会在HTTP请求的路径无法匹配任何RequestHandler类相对应的模式时返回404（Not Found）响应码。

400 Bad Request
如果你调用了一个没有默认值的get_argument函数，并且没有发现给定名称的参数，Tornado将自动返回一个400（Bad Request）响应码。

405 Method Not Allowed
如果传入的请求使用了RequestHandler中没有定义的HTTP方法（比如，一个POST请求，但是处理函数中只有定义了get方法），Tornado将返回一个405（Methos Not Allowed）响应码。

500 Internal Server Error
当程序遇到任何不能让其退出的错误时，Tornado将返回500（Internal Server Error）响应码。你代码中任何没有捕获的异常也会导致500响应码。

200 OK
如果响应成功，并且没有其他返回码被设置，Tornado将默认返回一个200（OK）响应码。

------


```python
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web

from tornado.options import define, options
define("port", default=8000, help="run on the given port", type=int)

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        greeting = self.get_argument('greeting', 'Hello')
        self.write(greeting + ', friendly user!')
    def write_error(self, status_code, **kwargs):
        self.write("Gosh darnit, user! You caused a %d error." % status_code)

if __name__ == "__main__":
    tornado.options.parse_command_line()
    app = tornado.web.Application(handlers=[(r"/", IndexHandler)])
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()
```

1. Tornado将默认向客户端发送一个包含状态码和错误信息的简短片段。
2. 重写write_error方法在你的RequestHandler类中。

错误请求示例：
```shell
curl -d foo=bar http://localhost:8000/
# 响应
Gosh darnit, user! You caused a 405 error.
```